# 응용 SW 기초 기술 활용

## (11-1) 운영체제의 특징

### 1. 운영체제(OS; Operating System)
- 사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어
- 한정된 시스템 자원을 효과적으로 사용할 수 있도록 관리 및 운영함으로써 사용자에게 편리성 제공
- 컴퓨터 시스템과 사용자 간의 인터페이스 기능 담당
- 특징: 사용자 편리성 제공, 인터페이스 기능 담당, 스케줄링 담당, 자원 관리, 제어 기능
- 커널(Kernel)
  - 운영체제의 핵심이 되는 기능들이 모여 있는 컴퓨터 프로그램
  - 운영체제는 크게 인터페이스(쉘) + 커널의 구조임
  - 인터페이스(GUI)는 커널을 사용자가 편리하게 사용할 수 있게 해줌
  - 커널은 쉘(Shell)과 대비됨
  - 쉘은 운영체제 가장 바깥 부분에 위치하여 사용자 명령에 대한 처리 담당
  - 커널은 하드웨어 관련 내부적 역할 담당(프로세스, 기억장치, 주변장치, 파일 관리)


### 1-1. 운영체제의 종류
- 1 윈도즈(Windows) 운영체제
  - MS-DOS의 멀티태스킹 기능과 GUI 환경을 제공하는 마이크로소프트사가 개발한 운영체제
  - 윈도즈 95 발표 이후 98, ME, XP, 7, 8, 10 등의 버전으로 지속적 출시
  - 특징
    - 그래픽 사용자 인터페이스 제공
    - 선점형 멀티태스킹 방식 제공
    - 자동감지 기능 제공
    - OLE(Object Linking and Embedding) 사용
- 2 유닉스(Unix) 계열 운영체제
  - 교육 및 연구 기관에서 사용되는 범용 다중 사용자 방식의 시분할 운영체제
  - 유닉스는 처음부터 다양한 시스템에 서로 이식할 수 있고, 멀티 태스킹과 다중 사용자를 지원하도록 설계됨
  - 특징
    - 대화식 운영체제 기능 제공
    - 다중 작업 기능 제공
    - 다중 사용자 기능 제공
    - 이식성 제공
    - 계층적 트리 구조 파일 시스템 제공
  - (1) 리눅스 운영체제
    - 유닉스 기반 개발, 소스코드가 공개된 오픈 소스 기반의 운영체제
    - 리눅스는 데비안, 레드헷, Fedora, Ubuntu, CentOS와 같이 다양하게 출시됨
    - 유닉스 계열의 운영체제이므로 대화식 운영체제, 다중 작업 기능, 다중 사용자 기능, 이식성, 계층적 트리 구조 파일 시스템 갖춤
  - (2) 맥 운영체제
    - 애플이 유닉스를 기반으로 개발한 그래픽 사용자 인터페이스 기반의 운영체제 
  - (3) 안드로이드 운영체제
    - 휴대 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어, 사용자 인터페이스, 표준 응용 프로그램을 포함
    - 특징: 리눅스 기반, 자바와 코틀린 언어, 런타임 라이브러리, 안드로이드 소프트웨어 개발 키트


### 2. 운영체제 제어
- CLI(Command Line Interface): 사용자가 직접 명령어를 입력, 컴퓨터에 명령을 내리는 방식
- GUI(Graphic User Interface): 마우스로 화면을 클릭하여 그래픽 위주로 컴퓨터를 제어하는 방식


### 2-1. 윈도즈 운영체제 기본 명령어
- 윈도즈 운영체제에서 CLI 명령어를 입력하기 위해서는 명령 창이 필요
- Help를 명령 창에 입력하여 검색 가능
- 윈도즈 내에서는 파일을 이동하고 프로그램을 실행하는 것과 같은 행동을 GUI 명령으로 제어 가능
- 기본 명령어
  |명령어|설명|
  |:--:|:--:|
  |ATTRIB|파일 속성을 표시하거나 바꿈|
  |CALL|한 일괄 프로그램에서 다른 일괄 프로그램을 호출|
  |CD|현재 디렉터리 이름을 보여주거나 바꿈|
  |CHKDSK|디스크를 검사하고 상태 보고서를 표시|
  |CLS|화면을 지움|
  |CMD|윈도즈 명령 프롬프트 창을 열어줌|
  |COMP|두 개 이상의 파일을 비교|
  |DISKPART|디스크 파티션 속성을 표시하거나 구성|
  |ECHO|메시지를 표시하거나 ECHO를 사용 또는 사용하지 않음|
  |ERASE|하나 이상의 파일을 지움|
  |EXIT|CMD.EXE 프로그램(명령 인터프리터)를 마침|


### 2-2. 리눅스/유닉스 계열의 기본 명령어
- 리눅스와 유닉스 명령어는 쉘에서 입력할 수 있음
- 리눅스는 최상위 유저를 CLI 환경에서 #으로 표시, 일반 유저를 $로 표시
- 명령어에 대한 도움말은 --help, -h를 명령어 뒤에 붙임으로써 확인 가능
- 기본 명령어
  |구분|명령어|설명|
  |:--:|:--:|:--:|
  |시스템 관련|uname -a|시스템의 모든 정보를 확인하는 명령어|
  |--|uname -r|운영체제의 배포버전을 출력하는 명령어|
  |--|cat|파일의 내용을 화면에 출력하는 명령어|
  |--|uptime|시스템의 가동 시간과 현재 사용자 수, 평균 부하량 등을 확인하는 명령어|
  |사용자|id|사용자의 로그인명, 아이디, 그룹 아이디 등을 출력|
  |--|last|시스템의 부팅부터 현재까지의 모든 사용자의 로그인과 로그아웃에 대한 정보 표시|
  |--|who|현재 접속 사용자 정보를 표시|
  |파일 처리|ls|자신이 속해있는 폴더 내에서의 파일 및 폴더들을 표시|
  |--|pwd|현재 작업 중인 디렉토리의 절대 경로를 출력|
  |--|rm|파일 삭제|
  |--|cp|파일 복사|
  |--|mv|파일 이동|
  |프로세스|ps|현재 실행되고 있는 프로세스 목록을 출력|
  |--|pmap|프로세스 ID를 기준으로 메모리 맵 정보를 출력|
  |--|kill|특정 PID 프로세스 종료|
  |파일 권한|chmod|특정 파일 또는 디렉토리의 퍼미션 수정|
  |--|chown|파일이나 디렉토리의 소유자, 소유 그룹 수정|
  |네트워크|ifconfig|네트워크 인터페이스를 설정하거나 확인|
  |--|host|도메인(호스트)명은 알고 있는데 ip주소를 모르거나 혹은 그 반대의 경우에 사용|
  |압축|tar|여러 개의 파일을 하나의 파일로 묶거나 풀 때 사용(압축은 불가)|
  |--|gzip|파일을 묶거나 풀수는 없지만 압축을 담당|
  |검색|grep|입력으로 전달된 파일의 내용에서 특정 문자열을 찾고자할 때 사용|
  |--|find|특정한 파일을 찾을 때|
  |파일 이동|cp|디렉토리를 복사할 때|
  |--|rsync|로컬 또는 원격에 파일과 디렉토리를 복사하고 동기화|
  |디스크 사용|df|시스템에 마운트된 하드디스크의 남은 용량을 확인할 때|
  |--|du|파일 사이즈를 킬로 바이트 단위로 보여줌|
  |디렉터리 이동|cd|디렉토리를 이동함|


### 3. 리눅스/유닉스 운영체제의 파일 접근 권한 관리
- 리눅스/유닉스 시스템에서 사용자 혹은 프로세스가 파일을 읽거나 실행하면 open(), read(), write()와 같은 시스템 호출이 수행되고, 각 파일의 정보가 저장된 i-node(유닉스 계통 파일 시스템에서 사용하는 자료구조)값을 읽게 됨
- i-node에는 각 파일의 물리적 위치, 생성/수정/사용 날짜 등의 정보와 더불어 파일 소유자/그룹, 접근 권한 등의 파일 접근제어와 관련된 정보가 수록됨
- 해당 정보 이용하여 DAC(Digital to Analog Converter) 기반 접근제어 수행
- 리눅스/유닉스 파일 접근제어 매커니즘
  - 접근 권한 유형(설정 명령어:chown, chgrp)
    |접근 권한|설명|
    |:--:|:--:|
    |User|파일을 사용하고 있는 사용자|
    |Group|소유자를 제외하고 파일과 같은 그룹에 속해있는 모든 사용자 모임|
    |Other|그 밖의 사용자|
  - 파일 접근 모드(설정 명령어:chmod)
    |User|Group|Other|
    |:--:|:--:|:--:|
    |R(4) W(2) X(1)|R(4) W(2) X(1)|R(4) W(2) X(1)|
  - Read, Write, eXcute로 파일을 읽거나, 쓰거나, 실행할 수 있는 3가지 모드로 구분
  - 파일이 'rwx' 모드를 지원한다면 위의 3가지가 가능하다는 것을 의미


### 3-1. 접근 권한 변경(chmod)
- 1 명령어
  - chmod [-R ] permission file_name1 | directory_name1 [file_name2|directory_name2.. ]
  - chmod 명령은 기존 파일 또는 디렉토리에 대한 접근 권한을 변경할 때 사용
  - 옵션 -R : 하위 디렉토리와 파일의 권한까지 변경
  - permission : 기호나 8진수로 접근 권한을 지정
  - 예시) chmod o-w A (A에 대한 other의 쓰기 권한 제거)
  - 해당 파일의 소유주나 슈퍼 유저 root 만이 실행 가능
- 2 접근 권한을 기호로 기술하는 방법
    |구분|기술 방법|
    |:--:|:--:|
    |대상|u(user), g(group), o(other), a(all)|
    |연산자|+(추가), -(제거), =(지정)|
    |접근 권한|r(읽기), w(쓰기), x(실행)|
  - 예시) chmod g+w, o-x A (A의 group에 w 권한을 추가하고 others에 x 권한 제거)
- 3 접근 권한을 숫자로 기술하는 방법
  - 파일의 접근 권한을 세 개의 8진수로 기술
  - 예시) chmod 664 A (user, group에 rw(6) 권한, others에 r(4) 권한 설정)


### 4. 운영체제 핵심 기능
- 운영체제는 중앙처리장치, 메모리, 스토리지, 주변 기기 등을 적절히 관리함
- 초기에는 메모리 용량에 제한 많아 개발 시 메모리 관리가 매우 중요했으나
- 최근 들어 운영체제에서 대부분 자동으로 관리해 주므로 사용이 편리해짐
- 개발 및 시스템 환경이 클라우드화되면서 자원에 대한 관리 노력이 줄어듦
- 1 메모리 관리
  - 프로그램의 실행이 종료될 때까지 메모리를 가용한 상태로 유지 및 관리하는 기능
  - 메모리가 꽉 차게 되면 시스템의 속도가 느려지고 때로는 시스템이 멈추는 현상 발생
  - 메모리에 있는 프로그램은 CPU로 이동하여 처리
  - CPU는 가상 주소를, 메모리는 물리 주소를 사용하는데 MMU가 주소를 매핑하는 역할 수행
  - MMU : CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품, 가상 메모리 주소를 실제 메모리 주소로 변환
- 2 프로세스 관리
  - 프로세스 관리 기법에는 '일시 중지 및 재실행', '동기화', '통신', '교착상태 처리', '프로세스 생성 삭제' 가 있음


### 4-1. 메모리 관리 기법
- 반입 기법
  - 주기억장치에 적재할 다음 프로세스의 반입 시기를 결정하는 기법
  - 메모리로 적재 시기 결정(When)
  - 요구 반입 기법, 예상 반입 기법
- 배치 기법
  - 디스크에 있는 프로세스를 주기억장치의 어느 위치에 저장할 것인지 결정하는 기법
  - 메모리 적재 위치 결정(Where)
  - 최초 적합, 최적 적합, 최악 적합
- 할당 기법
  - 실행해야 할 프로세스를 주기억장치에 어떤 방법으로 할당할 것인지 결정하는 기법
  - 메모리 적재 방법 결정(How)
  - 연속 할당 기법, 분산 할당 기법
- 교체 기법
  - 재배치 기법으로 주기억장치에 있는 프로세스 중 어떤 프로세스를 제거할 것인지를 결정하는 기법
  - 메모리 교체 대상 결정(Who)
  - 프로세스의 Swap In/Out, FIFO, Optimal, LRU, LFU, 시계 알고리즘, MFU


### 4-2. 프로세스 관리
- 1 프로세스 상태
  - 하나의 프로세스는 여러 가지 이벤트의 의해 일련의 서로 구분되는 상태 변화를 겪음
  - 생성 상태, 준비 상태, 실행 상태, 대기 상태, 완료 상태를 가질 수 있음
    |상태|설명|
    |:--:|:--:|
    |생성(Create)|사용자에 의해 프로세스가 생성된 상태|
    |준비(Ready)|CPU를 할당받을 수 있는 상태|
    |실행(Running)|프로세스가 CPU를 할당받아 동작 중인 상태|
    |대기(Waiting)|프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태|
    |완료(Complete)|프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태|
- 2 프로세스 상태 전이
  - 하나의 작업이 컴퓨터 시스템에 입력되어 완료되기까지 프로세스의 상태가 준비, 실행 및 대기 상태로 변하는 활동
  - 활동 상태 : 프로세스가 기억장치를 할당받은 상태
  - 지연 상태 : 프로세스가 기억장치를 할당받지 못한 상태
  - 상태 전이 설명
    - 디스패치(Dispatch)
      - 준비 상태에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU를 할당(문맥교환 발생)
      - 문맥교환(Context switching): CPU가 현재 실행하고 있는 프로세스의 문맥 상태를 프로세스 제어블록(PCB)에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업
    - 타이머 런 아웃(Timer run out) = 할당 시간 초과
      - CPU를 할당받은 프로세스는 지정된 시간이 초과되면 스케줄러에 의해 PCB 저장, CPU 반납 후 다시 준비 상태로 전이됨
      - 타임 슬라이스(Time Slice) 만료, 선점(Preemption) 시 타임아웃 발생
    - 블록(Block) = 입출력 발생
      - 실행 상태에 있는 프로세스가 지정된 할당시간을 초과하기 전에 입출력이나 기타 사전이 발생(block)하면 CPU를 스스로 반납하고 입출력이 완료될 때까지 대기 상태로 전이됨
      - 즉시 실행 불가능한 시스템 콜, I/O 작업 시작, 프로세스간 통신 시 Block 발생
    - 웨이크 업(Wake-up) = 깨움
      - 어느 순간에 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 wait & signal 등에 의해 알려주고, 준비 상태로 전이됨


### 4-3. 프로세스 스케줄링
- CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업
- 스케줄링은 처리율과 CPU 이용률은 증가시키고 오버헤드, 응답시간, 반환시간, 대기시간을 최소화시키기 위한 기법임
- 특정 프로세스가 적합하게 실행되도록 프로세스 스케줄링에 의해 프로세스 사이에서 CPU 교체가 일어남
- 프로세스 스케줄링을 실행하는 스케줄러의 유형에는 장기, 중기, 단기 스케줄러 존재
- 주요 용어
  - 서비스 시간 : 프로세스가 결과를 산출하기까지 소요되는 시간
  - 응답시간(반환시간) : 프로세스들이 입력되어 수행하고 결과를 산출하기까지 소요되는 시간, 대기시간+수행시간
  - 평균 응답시간(평균 반환시간) : 대기 큐의 프로세스가 결과를 산출하기까지 소요되는 시간 평균
  - 대기시간 : 프로세스가 프로세서에 할당 대기까지 큐에 대기하는 시간, 도착 즉시 할당되면 대기시간은 0 이 됨
  - 평균 대기시간 : 프로세스가 대기 큐에서 대기하는 평균 시간
  - 종료시간 : 요구되는 Processing time을 모두 수행하고 종료된 시간
  - 시간 할당량 : 한 프로세스가 프로세서를 독점하는 것을 방지하기 위해 서비스되는 시간 할당량
  - 응답률 : (대기시간 + 서비스 시간) / 서비스 시간, HRN(Highest Responce ratio Next) 스케줄링에서 사용
- 프로세스 스케줄링 유형
  - 1 선점형 스케줄링(Preemptive Scheduling)
    - 하나의 프로세스가 CPU를 차지하고 있을 때 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 방식
    - 빠른 응답과 대화식 시분할 시스템에 적합
    - 높은 우선순위 프로세스들이 들어오는 경우 오버헤드 초래
    - 알고리즘 : 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐
    - 실시간 응답 환경, Deadline 응답 환경에 활용됨
  - 2 비선점형 스케줄링(Non Preemptive Scheduling)
    - 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식
    - 응답시간 예상이 용이하고 모든 프로세스에 대한 요구를 공정하게 처리
    - 짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기
    - 알고리즘 : 우선순위, 기한부, FCFS, HRN, SJF
    - 처리시간 편차가 적은 특정 프로세스 환경에 활용됨


### 4-4. 프로세스 스케줄링 알고리즘
- 선점형 스케줄링 알고리즘 유형
  - 라운드 로빈(Round Robin)
    - 프로세스는 같은 크기의 CPU 시간을 할당(시간 할당량)
    - 시간 할당량(Time Quantum) : 프로세스가 선점방식의 다중 작업 시스템에서 작업을 실행할 수 있는 시간대
    - 프로세스가 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고,
    - CPU는 대기 중인 다음 프로세스로 넘어감
    - ☆균등한 CPU점유시간, 시분할 시스템 사용
  - SRT(Shortest Remaining Time First)
    - 가장 짧은 시간이 소요되는 프로세스를 먼저 수행하고, 
    - 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점됨
    - ☆짧은 수행시간 프로세스 우선 수행
  - 다단계 큐(Multi Level Queue)
    - 작업들을 여러 종류 그룹으로 분할, 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점 당함
    - 각 큐는 자신만의 독자적인 스케줄링 가짐
    - ☆독립된 스케줄링 큐
  - 다단계 피드백 큐(Multi Level Feedback Queue)
    - 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 시간 할당량을 부여
    - FCFS(FIFO)와 라운드 로빈 스케줄링 기법을 혼합한 것으로,
    - 새로운 프로세스는 높은 우선순위, 프로세스의 실행시간이 길어질수록 점점 낮은 우선순위 큐로 이동
    - 마지막 단계는 라운드 로빈 방식 적용
    - ☆큐마다 다른 시간 할당량
- 비선점형 스케줄링 알고리즘 유형
  - 우선순위(Priority)
    - 프로세스별로 우선순위가 주어지고, 우선순위에 따라 CPU를 할당함
    - 동일 순위는 FCFS
    - ☆주요/긴급 프로세스에 대한 우선 처리
  - 기한부(Deadline)
    - 작업들이 명시된 시간이나 기한 내에 완료되도록 계획
    - ☆요청에 명시된 시간 내 처리 보장
  - FCFS(First Come First Service)
    - 프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할당함
    - FIFO 알고리즘이라고도 함
    - ☆도착한 순서대로 처리
  - SJF(Shortest Job First)
    - 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 점유
    - 준비 큐 작업 중 가장 짧은 작업부터 수행, 평균 대기 시간 최소
    - CPU 요구 시간이 긴 작업과 짧은 작업 간의 불평등이 심함
    - ☆CPU 요구 시간이 긴 프로세스의 기아 현상 발생 가능성
  - HRN(Highest Response Ratio Next)
    - 대기 중인 프로세스 중 현재 응답률(Response Ratio)이 가장 높은 것을 선택
    - SJF의 약점인 기아 현상을 보완한 기법으로 긴 작업과 짧은 작업 간의 불평등 완화
    - ☆기아 현상(starvation) 최소화 기법





