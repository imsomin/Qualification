# 애플리케이션 테스트 관리

## (10-1) 애플리케이션 테스트 케이스 설계

### 1. 소프트웨어 테스트
- 개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성 등을 만족하는지 확인하고, 노출되지 않은 숨어있는 소프트웨어의 결함을 찾아내는 활동
- 소프트웨어 테스트 필요성 : 오류 발견, 오류 예방, 품질 향상
- 소프트웨어 테스트 원리
  - 테스팅은 결함이 존재함을 밝히는 것
  - 완벽한 테스팅은 불가능
  - 개발 초기에 테스팅 시작: 초기에 체계적인 분석이 수행되지 못하면 후반에 영향을 많이 미치게 된다(요르돈, 눈덩이 법칙)
  - 결함집중: 오류의 80%는 전체 모듈의 20% 내에서 발견, 파레토 법칙인 80 대 20 법칙 적용
  - 살충제 패러독스: 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함, 다른 시각에서의 접근 필요
  - 테스팅은 정황에 의존적
  - 오류-부재의 궤변: 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음
- 소프트웨어 테스트 프로세스
  - 1 테스트 계획
  - 2 테스트 분석 및 디자인
  - 3 테스트 케이스 및 시나리오 작성
  - 4 테스트 수행
  - 5 테스트 결과 평가 및 리포트
- 소프트웨어 테스트 산출물
  - 테스트 계획서, 테스트 베이시스, 테스트 케이스, 테스트 슈트, 테스트 시나리오, 테스트 스크립트, 테스트 결과서


### 2. 소프트웨어 테스트 유형
- 1 프로그램 실행 여부에 따른 분류
  - 정적 테스트: 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트
  - 동적 테스트: 소프트웨어를 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트
- 2 테스트 기법에 따른 분류
  - 화이트박스 테스트: 각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트
    - 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제가 발생할 가능성이 있는 모듈 내부를 테스트
    - 내부 소스 코드의 동작을 개발자가 추적할 수 있기 때문에 동작의 유효성과 실행 과정 확인 가능
    - 구조 기반 테스트, 코드 기반 테스트, 로직 기반 테스트, 글래스 박스 테스트라고 불림
    - 테스트 유형
      - 구문 커버리지, 문장 커버리지
      - 결정 커버리지, 선택 커버리지
      - 조건 커버리지
      - 조건/결정 커버리지
      - 변경 조건/결정 커버리지
      - 다중 조건 커버리지
      - 기본 경로 커버리지, 경로 커버리지
      - 제어 흐름 테스트
      - 데이터 흐름 테스트
  - 블랙박스 테스트: 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트
    - 소프트웨어의 특징, 요구사항, 설계 명세서 등에 초점을 맞춰 테스트가 이루어짐
    - 기능 및 동작 위주의 테스트를 진행하기 때문에 내부 구조나 작동 원리를 알지 못해도 가능함
    - 기능 테스트 혹은 명세 테스트라고도 불림
    - 테스트 유형
      - 동등분할 테스트, 동치 분할 테스트, 균등 분할 테스트, 동치 클래스 분해 테스트
      - 경곗값 분석 테스트, 한곗값 테스트
      - 결정 테이블 테스트
      - 상태 전이 테스트
      - 유스케이스 테스트
      - 분류 트리 테스트
      - 페어와이즈 테스트
      - 원인-결과 그래프 테스트
      - 비교 테스트
- 3 테스트 시각에 따른 분류
  - 검증: 개발자 혹은 시험자의 시각으로 소프트웨어가 명세화된 기능을 올바로 수행하는지 알아보는 과정
  - 확인: 사용자 시각으로 올바른 소프트웨어가 개발되었는지 입증하는 과정
- 4 테스트 목적에 따른 분류
  - 회복 테스트: 고의로 실패 유도 후 정상적 복귀 여부 테스트
  - 안전 테스트: 소스코드 내 보안적인 결함 미리 점검
  - 성능 테스트: 사용자 요구에 시스템이 반응하는 속도 등을 측정
    - 부하 / 스트레스 / 스파이크 / 내구성
  - 구조 테스트: 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가
  - 회귀 테스트: 오류를 제거하거나 오류가 있는지 확인하는 일종의 반복 테스트 기법
  - 병행 테스트: 변경된 시스템과 기존 시스템에 동일 데이터 입력 후 결과 비교 
- 5 테스트 종류에 따른 분류
  - 명세 기반 테스트
  - 구조 기반 테스트
  - 경험 기반 테스트


### 3. 정적 테스트
- 테스트는 크게 정적 테스트와 동적 테스트로 나눠질 수 있고, 정적 테스트는 리뷰와 정적 분석으로 분류된다.
- 리뷰(Review)
  - 소프트웨어의 다양한 산출물에 존재하는 결함을 검출하거나 프로젝트의 진행 상황을 점검하기 위한 활동
  - 프로세스: 경영진 준비, 리뷰 계획, 리뷰 절차 개요 설명, 작업물 개요 설명, 개별 준비, 그룹 검토, 재작업, 후속 작업
  - 리뷰 유형
    - 관리 리뷰: 프로젝트 진행 상황에 대한 전반적인 검토를 바탕으로 의사 결정 지원
    - 기술 리뷰: 정의된 계획 및 명세를 준수하고 있는지에 대한 검토 수행
    - 인스펙션: 저작자 외의 다른 전문가 또는 팀이 검사하여 문제 식별
    - 워크스루: 검토 자료를 회의 전에 배포해서 사전 검토 후 짧은 시간 동안 회의 진행
    - 감사: 제품이 가이드라인을 준수하고 있는지를 독립적으로 평가
- 정적 분석(Static Analysis)
  - 리뷰는 수작업 중심의 방법인 반면, 정적 분석은 도구의 지원을 받아 정적 테스트를 수행
  - 자동화된 도구를 이용하여 산출물의 결함을 검출하거나 복잡도를 측정
  - 정적 분석 유형
    - 코딩 표준
    - 복잡도 측정
    - 자료 흐름 분석


### 4. 동적 테스트 - (1)화이트박스 테스트
- 화이트박스 테스트(구조 기반 테스트)
  - 제어 흐름 그래프는 프로그램 구조를 효과적으로 나타낼 수 있는 도구이다.
  - 우선 프로그램을 기본 블록과 제어 흐름으로 구성된 제어 흐름 그래프를 그린 후에 테스트 케이스를 추출한다.
  - 테스트 커버리지는 프로그램의 테스트 수행 정도를 나타내는 값으로 테스트 수행의 완벽성을 측정하는 도구이다.
  - 테스트 커버리지는 주어진 테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 측정 기준이다.
  - 테스트 커버리지 유형
    - 기능 기반 커버리지
    - 라인 커버리지
    - 코드 커버리지
  - 테스트 커버리지 구성(구문, 결정, 조건, 결정 포인트)
    - 구문(문장) 커버리지(Statement Coverage)
      - 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 테스트 커버리지
    - 결정 커버리지(Decision Coverage)
      - 각 분기의 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과를 수행하는 테스트 커버리지
    - 조건 커버리지(Condition Coverage)
      - 각 분기의 결정 포인트 내의 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지
    - 조건/결정 커버리지(Condition/Decision Coverage)
      - 조건 커버리지와 결정 커버리지를 최소한의 조합으로 달성하는 커버리지
    - 변경 조건/결정 커버리지(Modified Condition/Decision Coverage)
      - 각 개별 조건식이 다른 개별 조건식에 영향을 받지 않고, 전체 조건식의 결과에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시키는 커버리지
    - 다중 조건 커버리지(Mutiple Condition Coverage)
      - 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 테스트 커버리지
    - 기본 경로 커버리지
      - 맥케이브(McCabe)의 순환복잡도를 기반으로 커버리지 계산, 수행 가능한 모든 경로를 테스트
    - 제어 흐름 테스트(Control Flow Testing)
      - 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법


### 4-1. 동적 테스트 - (2)블랙박스 테스트
- 블랙박스 테스트(명세 기반 테스트)
  - 모든 종류의 소프트웨어 시스템에 대해 테스트 가능
  - 전체 소프트웨어 테스트 레벨(단위, 통합, 시스템, 인수)에서 적용할 수 있는 기법
  - 1 동등분할 테스트(Equivalance Partitioning Testing)
    - 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출
  - 2 경곗값 분석 테스트(Boundary Value Analysis Testing)
    - 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스 설계
  - 3 결정 테이블 테스트(Decision Table Testing)
    - 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트
  - 4 상태 전이 테스트(State Transition Testing)
    - 테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행
  - 5 유스케이스 테스트(Use Case Testing)
    - 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행
  - 6 분류 트리 테스트(Classification Tree Method Testing)
    - SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계
  - 7 페어와이즈 테스트(Pairwise Testing)
    - 테스트 데이터값들 간에 최소한 한 번씩을 조합하는 방식, 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법


### 4-2. 동적 테스트 - (3)경험 기반 테스트
- 유사 소프트웨어나 유사 기술 평가에서 테스터의 경험을 토대로 한 직관과 기술 능력을 기반으로 수행하는 테스트 기법
- 유형
  - 탐색적 테스트
  - 오류 추정
  - 체크리스트
  - 특성테스트


### 5. 테스트 케이스(Test Case)
- 특정 요구사항에 준수하는 지를 확인하기 위해 개발된 입력값, 실행 조건, 예상된 결과의 집합
- 구성요소
  - 식별자
  - 테스트 항목
  - 입력 명세
  - 출력 명세
  - 환경 설정
  - 특수절차요구
  - 의존성 기술


### 6. 테스트 오라클(Test Oracle)
- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법
- 종류
  - 참 오라클: 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클
  - 샘플링 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클
  - 휴리스틱 오라클: 특정 입력값에 대해 올바른 결과를 제공하고 나머지 값들에 대해서는 휴리스틱(추정)으로 처리
  - 일관성 검사 오라클: 애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인


### 7. 테스트 레벨(Test Level)
- 함께 편성되고 관리되는 테스트 활동의 그룹
- 프로젝트에서 책임과 연관됨
- 각각의 테스트 레벨은 서로 독립적
- 종류
  - 단위 테스트
  - 통합 테스트
  - 시스템 테스트
  - 인수 테스트


### 8. 테스트 시나리오(Test Scenario)
- 테스트 수행을 위한 여러 테스트 케이스의 집합으로서, 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서
- 테스트 항목을 하나의 시나리오에 모두 작성하지 않고 시스템별, 모듈별, 항목별 테스트 시나리오를 분리하여 작성
- 고객의 요구사항과 설계 문서 등을 토대로 테스트 시나리오 작성
- 각 테스트 항목은 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인 등의 항목을 포함하여 작성
 

___



## (10-2) 애플리케이션 통합 테스트

### 1. 단위 테스트(Unit Test)
- 단위(컴포넌트) 테스트는 개별적인 모듈(또는 컴포넌트)을 테스트함
- 구현 단계에서 각 모듈을 구현한 후 수행
- 개별적인 모듈에 대해 컴포넌트 테스트를 수행하려면 모듈을 단독으로 실행할 수 있는 테스트 베드(Test Bed)라는 환경 필요


### 1-1. 목(Mock) 객체 생성 프레임워크
- 객체지향 프로그램에서는 컴포넌트 테스트 수행 시 테스트 되는 메서드는 다른 클래스의 객체에 의존
- 이런 경우 메서드를 고립화하여 테스트하는 것이 불가능하므로 독립적인 컴포넌트 테스트를 위해서 스텁의 객체지향 버전인 목 객체가 필요함
- 목 객체는 개발자가 수작업으로 만들거나 목 객체 생성 프레임워크를 활용하여 생성 가능
- 목 객체 유형
  - 더미 객체(Dummy)
    - 테스트할 때 객체만 필요하고 해당 객체의 기능까지는 필요하지 않은 경우에 사용
    - 더미 객체의 메서드가 호출되면 정상 동작은 수행하지 않고 예외 수행
  - 테스트 스텁(Stub)
    - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
    - 더미 객체에의 단순 기능에 특정 상태를 가정해서 특정한 값을 리턴하거나 특정 메시지 출력
  - 테스트 드라이버(Driver)
    - 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과 도출
  - 테스트 스파이(Spy)
    - 주로 테스트 대상 클래스와 협력하는 클래스로 가는 출력을 검증하는 데 사용
  - 가짜 객체(Fake)
    - 실제 협력 클래스의 기능을 대체해야 할 경우에 사용
    - 실제 협력 클래스의 기능 중 전체나 일부를 훨씬 단순하게 구현


### 1-2. 단위 테스트 원칙
- 단위(컴포넌트) 테스트는 빠르게 수행되어야 하고, 다른 컴포넌트에 의존하지 않도록 해야 한다.
- 테스트를 몇 번 실행해도 동일한 결과가 나와야 하고, 사람의 개입 없이 테스트가 통과되었는지 알 수 있도록 작성해야 한다.


### 2. 통합 테스트(Integration Test)
- 애플리케이션 통합 테스트는 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법임
- 단위 테스트가 끝난 모듈 또는 컴포넌트 단위의 프로그램이 설계 단계에서 제시한 애플리케이션과 동일한 구조와 기능으로 구현된 것인지를 확인하는 테스트
- 일반적으로 점증적인 방법과 비점증적인 방식으로 나누어짐
- 비점증적인 방식은 모든 컴포넌트를 사전에 통합하여 전체 프로그램을 한꺼번에 테스트하는 것을 말함
- 점증적인 방법은 다시 상향식 통합과 하향식 통합 방식으로 구분됨


### 2-1. 하향식 통합(Top Down)
- 메인 제어 모듈(프로그램)로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트를 진행
- 메인 제어 모듈에 통합되는 하위 모듈과 최하위 모듈은 '깊이-우선' 또는 '너비-우선' 방식으로 통합됨
- 수행 단계
  - 1 메인 제어 모듈은 작성된 프로그램을 사용하고, 아직 작성하지 않은 하위 모듈을 제어함
  - 2 위에서 아래로 내려오므로 검사 초기에 시스템 구조 파악 필요
  - 3 모듈 및 모든 컴포넌트를 대신하여 더미 모듈인 '스텁' 개발
  - 4 깊이-우선 방식 혹은 너비-우선 방식에 따라, 하위 모듈인 스텁이 한 번에 하나씩 실제 모듈로 대체
  - 5 각 모듈 또는 컴포넌트를 통합하면서 테스트 수행
  - 6 테스트가 완료되면 스텁이 실제 모듈 또는 컴포넌트로 작성
- 방식 비교
  - 깊이-우선(Depth-First): 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색
  - 너비-우선(Breadth-First): 루트 노드에서 시작해서 인접한 노드를 먼저 탐색


### 2-2. 상향식 통합(Bottom Up)
- 애플래케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트 수행
- 수행 단계
  - 1 하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터로 결합
  - 2 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈인 '드라이버' 작성
  - 3 각 통합된 클러스터 단위 테스트
  - 4 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합되며, 드라이버는 실제 모듈 또는 컴포넌트로 대체
- 장점 
  - 장애 위치 파악이 쉬우며 모든 모듈 개발 시간 낭비 필요 없음
- 단점
  - 중요 모듈들이 마지막 테스트일 가능성 높음
  - 이른 프로토타입이 어려움


### 2-3. 샌드위치 통합
- 상향식 통합 테스트와 하향식 통합 테스트 방식을 결합한 테스트 방식
- 하위 프로젝트가 있는 큰 규모의 통합 테스트에서 사용하는 방식
- 병렬 테스트 가능
- 시간 절약 가능
- 스텁과 드라이버의 필요성이 높음
- 많은 비용 소요


### 3. 테스트 자동화 도구
- 테스트 도구를 활용하여 반복적인 테스트 작업을 스크립트 형태로 구현함으로써, 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트를 수행할 수 있는 방법


### 3-1. 테스트 자동화 도구 유형 - (1)정적 분석 도구(Static Analysis Tools)
- 만들어진 애플리케이션을 실행하지 않고 분석하는 도구
- 소스코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위하여 사용
- 테스트를 수행하는 사람이 작성된 소스코드에 대한 이해를 바탕으로 도구를 이용해서 분석하는 것


### 3-2. 테스트 자동화 도구 유형 - (2)테스트 실행 도구(Test Execution Tools)
- 테스트를 위해 작성된 스크립트를 실행하고, 작성된 스크립트는 각 스크립트마다 특정 데이터와 테스트 수행 방법 포함
- 데이터 주도 접근 방식
  - 테스트 데이터를 스프레드시트에 저장
  - 다양한 데스트 데이터를 이용하여 동일한 테스트 케이스를 반복해서 실행
- 키워드 주도 접근 방식
  - 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 스프레트시트에 저장
  - 키워드를 이용하여 테스트 수행 동작 정의 가능


### 3-3. 테스트 자동화 도구 유형 - (3)성능 테스트 도구(Performance Test Tools)
- 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 도구


### 3-4. 테스트 자동화 도구 유형 - (4)테스트 통제 도구(Test Control Tools)
- 테스트 통제 도구에는 테스트 계획 및 관리를 위한 테스트 관리 도구,
- 테스트 수행에 필요한 데이터와 도구를 관리하는 형상 관리 도구,
- 테스트에서 발생한 결함에 대해 관리하거나 협업을 지원하기 위한 결함 추적/관리 도구 등이 있다.
- 조직의 요구사항에 최적화된 형태의 정보를 생성, 관리하기 위하여 스프레트시트 등 다른 도구들과 연계하여 사용 가능


### 4. 테스트 하네스(Test Harness)
- 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로 테스트를 지원하기 위한 코드와 데이터
- 단위 또는 모듈 테스트에 사용하기 위해 코드 개발자가 작성함
- 구성 요소
  - 테스트 드라이버
  - 테스트 스텁
  - 테스트 슈트: 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
  - 테스트 케이스: 입력값, 실행 조건, 기대 결과 등의 집합
  - 테스트 스크립트: 자동화된 테스트 실행 절차에 대한 명세
  - 목 오브젝트: 사용자의 행위를 조건부로 사전에 입력해 두면, 그 상황에 예정된 행위를 수행하는 객체


### 5. 테스트 단계별 테스트 자동화 도구
- 1 테스트 계획
  - 요구사항 관리
- 2 테스트 분석/설계
  - 테스트 케이스 생성
- 3 테스트 수행
  - 테스트 자동화, 정적 분석, 동적 분석, 성능 테스트, 모니터링
- 4 테스트 관리
  - 커버리지 측정, 형상 관리, 결함 추적/관리
 

### 6. 소프트웨어 결함
- 에러/오류: 결함(Defect)의 원인이 되는 것으로, 일반적으로 사람에 의해 생성된 실수
- 결함/결점/버그: 에러 또는 오류가 원인이 되어 소프트웨어 제품에 포함되어 있는 결함
- 실패/문제: 소프트웨어 제품에 포함된 결함이 실행될 때 발생되는 현상


### 6-1. 테스트 완료 조건
- 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트 등 각 단계별 테스트를 언제 어떤 상황에서 종료할 것인지를 결정하는 기준


### 6-2. 테스트 리포팅
- 테스트 결과 정리
- 테스트 요약문서
- 품질 상태
- 테스트 결과서
- 테스트 실행 절차 리뷰 및 평가


### 6-3. 결함 관리
- 테스트 결함 관리는 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동임
- 프로세스 : 결함 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 및 모니터링 활동 → 최종 결함 분석 및 보고서 작성


### 6-4. 결함 분석
- 테스트 케이스를 실행한 후 발견된 결함을 분석하여 테스트 결함 보고서(테스트 사건 보고서)를 작성
- 방법
  - 구체화(Specification): 결함의 원인을 찾기 위해 결함을 발생시킨 입력값, 테스트 절차, 테스트 환경을 명확히 파악하는 방법
  - 고립화(Isolation): 입력값, 테스트 절차, 테스트 환경 중 어떤 요소가 결함 발생에 영향을 미치는지 분석하는 방법
  - 일반화(Generalization): 결함 발생에 영향을 주는 요소를 최대한 일반화 시키는 방법


### 6-5. 결함 생명주기 및 추적 관리 활동
- 결함 생명주기별 결함 상태
  - 결함 등록(Open)
  - 결함 검토(Reviewed)
  - 결함 할당(Assigned)
  - 결함 수정(Resolved)
  - 결함 확인(Verified)
  - 결함 종료(Closed)
  - 결함 재등록(Reopen)
  - 결함 조치 보류(Deferred)
- 결함 처리 유형
  - Fixed : 요청된 결함을 수정 완료 처리한 경우
  - Duplicated : 기존의 다른 결함과 중복되는 경우
  - Won't Fix : 수정이 필요할 정도로 중요하거나 긴급한 것이 아니므로 수정하지 않는 경우
  - Invalid : 테스트 케이스에 문제가 있는 경우
- 결함 추적 관리 활동
  |테스트 단계|착수 기준|
  |:--:|:--:|
  |단위 테스트|해당 사항 없음|
  |통합 테스트|설계 문서 결함 발견|
  |시스템 테스트|요구사항 명세서 결함 발견|
  |운영 테스트|요구사항 명세서 결함 발견|


### 6-6. 결함 추이 분석
- 테스트 완료 후 발견된 결함의 결함 관리 측정 지표의 속성값들을 분석하고, 향후 애플리케이션의 어떤 모듈 또는 컴포넌트에서 결함이 발생할 지를 추정하는 작업
- 유형
  - 결함 분포 분석: 각 애플리케이션 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함의 수를 측정하여 결함의 분포를 분석
  - 결함 추세 분석: 테스트 진행 시간의 흐름에 따른 결함의 수를 측정하여 결함 추세를 분석
  - 결함 에이징 분석: 등록된 결함에 대해 특정한 결함 상태의 지속 시간을 측정하여 분석


### 6-7. 테스트 커버리지(Test Coverage)
- 테스트 커버리지는 주어진 테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 측정 기준임
- 테스트의 정확성과 신뢰성을 향상시키는 역할을 함
- 유형
  - 기능 기반 커버리지: 테스트 대상 애플리케이션의 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 수를 측정하는 방법
  - 라인 커버리지: 애플리케이션 전체 소스 코드의 라인 수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인 수를 측정하는 방법
  - 코드 커버리지: 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트되었는지를 측정하는 방법, 일반적인 지표
- 일반적으로 테스트 커버리지라고 하면 코드 커버리지를 일컬으며 대표적인 유형으로 구문 커버리지, 결정 커버리지, 조건 커버리지 등이 있음


### 7. 결함의 분류
- 시스템 결함
  - 비정상적인 종료/중단, 응답 시간 지연, 데이터베이스 에러 등 주로 애플리케이션 환경과 데이터베이스 처리에서 발생하는 결함
- 기능 결함
  - 사용자의 요구사항 미반영/불일치, 부정확한 비즈니스 프로세스, 스크립트 에러, 타 시스템 연동 시 오류 등 기획, 설계, 업무 시나리오 단계에서 발생한 결함
- GUI 결함
  - 응용 프로그램의 UI 비일관성, 부정확한 커서/메시지, 데이터 타입의 표시 오류 등으로 사용자 화면 설계에서 발생한 결함
- 문서 결함
  - 기획자, 사용자, 개발자 간의 의사소통과 기록이 원활하지 않은 경우에 발생하는 결함


### 7-1. 단계별 결함 유입의 종류
- 기획 시 유입
- 설계 시 유입
- 코딩 시 유입
- 테스트 부족으로 유입


### 7-2. 결함 심각도별 분류
- 치명적(Critical) 결함
  - 기능이나 제품의 테스트를 완전히 방해하거나 못하게 하는 결함
  - 예시) 데이터 손실, 시스템 충돌
- 주요(Major) 결함
  - 기능이 기대와 많이 다르게 동작하거나 그 기능이 해야하는 것을 못하는 결함
  - 예시) 기능 장애
- 보통(Normal) 결함
  - 제품이나 프로그램이 특정 기준을 충족하지 못하거나 전체에 영향을 주지 않는 일부 기능이 부자연스러운 결함
  - 예시) 사소한 기능 오작동
- 경미한(Minor) 결함
  - 사용상의 불편함을 유발하는 결함
  - 예시) 표준 위반, UI 잘림
- 단순(Simple) 결함
  - 사소한 버그라고 하며, 기능에는 영향이 없지만 수정되어야 하는 결함
  - 예시) 미관상 좋지 않음


### 7-3. 결함 우선순위
- 발생한 결함이 얼마나 빠르게 처리되어야 하는지를 결정하는 척도
- 결함 심각도가 높아도 우선순위가 반드시 높은 것은 아니며, 애플리케이션의 특성에 따라 우선순위가 결정될 수 있음
- 우선순위
  - 결정적: 24시간 안에 즉시 수정
  - 높음: 중요한 결함이 수정되는 동안, 종료 기준에 대한 테스트 활동을 하기 위해서 수정되어야 하는 다음 후보
  - 보통: 실패가 발생했을 때 올바른 에러 메시지가 출력되지 않는 것과 같은 에러
  - 낮음: 디자인에서 일부 강화하거나 사용자 경험을 향상시키기 위한 작은 기능 구현
 

___



## (10-3) 애플리케이션 성능 개선

### 1. 애플리케이션 성능 측정 지표
- 처리량(Throughput): 애플리케이션이 주어진 시간에 처리할 수 있는 트랜잭션의 수
- 응답 시간(Response Time): 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때까지의 시간
- 경과 시간(Turnaround Time): 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료될 때까지 걸리는 시간
- 자원 사용률(Resource Usage): 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량


### 1-1. 유형별 성능 분석 도구
- 성능/부하/스트레스 점검 도구
  - 애플리케이션의 성능 점검을 위해 가상의 사용자를 점검 도구 상에서 인위적으로 생성한 뒤, 시스템의 부하나 스트레스를 통해 성능 측정 지표인 처리량, 응답 시간, 경과 시간 등을 점검하기 위한 도구
- 모니터링 도구
  - 애플리케이션 실행 시 자원 사용량을 확인하고 분석 가능한 도구
  - 성능 모니터링, 성능 저하 원인 분석, 시스템 부하량 분석, 장애 진단, 사용자 분석, 용량 산정 등의 기능을 제공하여, 시스템의 안정적 운영을 지원하는 도구


### 1-2. 성능 분석 도구 유형
- 성능 테스트 도구
  - JMeter
  - LoadUI
  - OpenSTA
- 시스템 모니터링 도구
  - Scouter
  - Zabbix


### 2. 애플리케이션 성능 저하 원인
- 1 데이터베이스 관련 성능 저하 원인
  - 데이터베이스 락: 대량의 데이터 조회, 과도한 업데이트, 인덱스 생성시 발생
  - 불필요한 데이터베이스 패치: 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 응답 시간 저하 현상 발생
  - 연결 누수: DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생
  - 부적절한 커넥션 풀 크기: 너무 작거나 크게 설정한 경우 성능 저하 현상 발생
  - 확정 관련: 트랜잭션이 확정(Commit)되지 않고 커넥션 풀에 반환될 때 성능 저하 가능성 존재
- 2 내부 로직으로 인한 성능 저하 원인
  - 웹 애플리케이션의 인터넷 접속 불량
  - 특정 파일의 업로드, 다운로드로 인한 성능 저하
  - 정상적으로 처리되지 않은 오류 처리로 인한 성능 저하
- 3 외부 호출(HTTP, 소켓 통신)로 인한 성능 저하 원인
  - 임의의 트랜잭션이 수행되는 동안 외부 트랜잭션이 장시간 수행되거나, 타임아웃이 일어나는 경우 성능 저하 현상 발생
- 4 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인
  - 환경 설정으로 인한 성능 저하: Thread Pool, Heap Memory의 크기를 너무 작게 설정
  - 네트워크 장비로 인한 성능 저하: 라우터, L4 스위치 등 네트워크 관련 장비 간 데이터 전송 실패 또는 전송 시연에 따른 데이터 손실


### 3. 애플리케이션 성능 테스트 - (1)테스트 케이스 작성
- 테스트 목표 및 목표값을 설정하여 작성
  - 테스트 상황 및 사용자 수, 호출 간격, TPS(Transaction Per Second), 응답 시간 등 목표값 설정
- 측정 항목을 기술하여 작성
  - TPS, 응답 시간, 시스템 사용률, 거래 성공 비율 등 측정 항목에 대해 기술
- 테스트 시나리오 작성
  - 성능 테스트에 대한 구체적인 방법 및 절차에 대해 작성
- 사전 확인 사항 작성
  - 테스트 시작 시간, 종료 시간, 스크립트(컴파일하지 않고도 실행할 수 있는 프로그램) 수행 횟수, 데이터베이스 상태 확인 등에 대해 작성


### 3-1. 애플리케이션 성능 테스트 - (2)테스트 수행 절차
- 성능 테스트 도구 설치
- 테스트 환경 설정
- 시나리오 생성
- 성능 테스트 실행 및 모니터링


### 4. 베드 코드(Bad Code)
- 다른 개발자가 로직을 이해하기 어렵게 작성된 코드
- 사례
  - 외계인 코드: 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드
  - 스파게티 코드: 처리 로직의 제어가 정제되지 않고 서로 얽혀 있는 코드
  - 알 수 없는 변수명: 변수나 메서드에 대한 이름 정의를 알 수 없는 코드
  - 로직 중복: 동일한 처리 로직이 중복되게 작성된 코드
- 유형
  - 오염: 비즈니스 기능을 수행하지 못하는 많은 컴포넌트들이 존재
  - 문서부족: 현재 코드와 문서가 일치하지 않고 수정과 변경을 위한 도메인 지식은 크게 증가하지만 개발자의 지식부족 초래
  - 의미 없는 이름: 함수, 클래스, 컴포넌트 이름들이 명확한 의미를 갖지 못하거나 실제 작동과 불일치
  - 높은 결합도: 클래스와 컴포넌트 간에 데이터와 컨트롤 흐름이 네트워크로 복잡하게 연결
  - 아키텍처 침식: 아키텍처가 더 이상 구별되지 않고 여러 솔루션을 이루어져 아키텍처상 변형들로 인해 시스템 품질이 떨어짐


### 5. 클린 코드(Clean Code)
- 잘 작성되어 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드
- 작성 원칙
  - 가독성: 이해하기 쉬운 용어를 사용, 코드 작성 시 들여쓰기 기능을 사용
  - 단순성: 한 번에 한 가지 처리만 수행, 클래스/메서드/함수를 최소 단위로 분리
  - 의존성 최소: 영향도를 최소화, 코드의 변경이 다른 부분에 영향이 없게 작성
  - 중복성 제거: 중복된 코드를 제거, 공통된 코드를 사용
  - 추상화: 클래스/메서드/함수에 대해 동일한 수준의 추상화 구현
- 소스 코드 최적화 기법의 유형(클린 코드의 유형)
  - 의미 있는 이름
  - 간결하고 명확한 주석
  - 보기 좋은 배치
  - 작은 함수
  - 읽기 쉬운 제어 흐름
  - 오류 처리
  - 클래스 분할 배치
  - 느슨한 결합 기법 적용
  - 코딩 형식 기법 적용


### 6. 소스 코드 품질분석
- 소스 코드에 대한 코딩 스타일, 설정된 코딩 표준, 코드의 복잡도, 코드 내에 존재하는 메모리 누수 현황, 스레드의 결함 등을 발견하기 위한 활동
- 정적 분석 도구
  - 작성된 소스 코드를 실행시키지 않고, 코드 자체만으로 코딩 표준 준수 여부, 코딩 스타일 적정 여부, 잔존 결함 발견 여부를 확인하는 코드 분석 도구
  - pmd : 자바 버그, 데드코드 분석
  - cppcheck : C/C++ 메모리 누수, 오버플로우 문제 분석
  - SonarQube : 소스 코드 품질 통합 플랫폼, 플러그인 확장 가능
  - checkstyle : 자바 코드에 대한 코딩 표준 검사 도구
  - ccm : 다양한 언어의 코드 복잡도 분석 도구, 리눅스, 맥 환경 CLI 형태 지원
  - cobertura : jcoverage 기반의 테스트 커버리지 측정 도구
- 동적 분석 도구
  - 애플리케이션을 실행하여 코드에 존재하는 메모리 누수 현황을 발견하고, 발생한 스레드의 결함 등을 분석하기 위한 도구
  - Avalanche : Valgrind 프레임워크 및 STP 기반 소프트웨어 에러 및 취약점 동적 분석 도구
  - Valgrind : 자동화된 메모리 및 스레드 결함 발견 분석 도구


### 7. 애플리케이션 성능 개선 방안
- 1 소스 코드 최적화 기법 적용
  - 애플리케이션 개발 프레임워크의 코딩 표준 설정, 인터페이스 클래스를 이용하여 느슨한 결합 코드 구현
  - 인터페이스를 통해 추상화된 자료 구조를 구현하여 의존성 최소화
- 2 아키텍처 조정을 통한 성능 개선
  - 객체의 생성과 사용을 분리함으로써 소프트웨어의 의존성을 최소화하기 위하여 팩토리 메서드 패턴을 이용하여 성능 개선 방안 수행
- 3 프로그램 호출 순서 조정 적용
  - 호출하는 함수를 먼저 코딩하고, 호출되는 함수는 나중에 배치
  - 서로 연관된 내용은 세로로 가깝게 작성하여 밀집도 높이고, 유사성이 높은 함수나 코드끼리 가깝게 배치
- 4 소스 코드 품질분석 도구 활용
  - 메모리 사용 최소화 적용: String 클래스를 StringBuffer 또는 StringBuilder 클래스로 수정, 불필요한 메서드 호출 반복 방지
  - 입출력 발생 최소화 적용: 문자 입력 스트림 또는 정보를 읽어올 때 BufferedReader를 사용하여 입출력 발생 최소화
  - System.out.println()을 사용 제외: 파일, 콘솔에 로그를 남기면 애플리케이션 대기 시간 발생, Log4j 로거를 사용하여 성능 개선
- 5 리팩토링 통한 성능 개선
  - 리팩토링(Refactoring): 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법
  - 소프트웨어 모듈의 외부적 기능은 수정하지 않고 내부적으로 구조, 관계 등을 단순화하여 소프트웨어의 유지보수성을 향상시킴
  - 목적: 유지보수성 향상, 유연한 시스템, 생산성 향상, 품질향상
- 6 애플리케이션 성능 현황 관리
  - 성능 현황판(Q-Board) 작성








