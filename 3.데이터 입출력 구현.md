# 데이터 입출력 구현

## (3-1) 논리 데이터 저장소 확인

### 1. 데이터 모델(Data Model)
- 현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델
- 데이터 모델에 표시해야 할 요소에는 논리적 데이터 구조, 연산, 제약조건이 있음


### 1-1. 데이터 모델 절차
- 개념적 → 개체관계 다이어그램
- 논리적 → 정규화
- 물리적 → 반 정규화


### 2. 논리 데이터 모델링
- 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스
- 개념 모델로부터 업무 영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델
- 종류
  - 관계 데이터 모델
  - 계층 데이터 모델
  - 네트워크 데이터 모델


### 2-1. 관계 데이터 모델
- 데이터를 행과 열로 구성된 2차원 테이블 형태로 구성한 모델 by E.F.Codd
- 구성요소 ★
  - 릴레이션 : 행(Row)과 열(Column)로 구성된 테이블
  - 튜플(Tuple) : 릴레이션의 행에 해당되는 요소
  - 속성(Attribute) : 릴레이션의 열에 해당되는 요소
  - 카티널리티(Cardinality) : 튜플의 수
  - 차수(Degree) : 애트리뷰트의 수
  - 스키마(Schema) : 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
  - 인스턴스(Instance) : 정의된 스키미에 따라 생성된 테이블에 실제 저장된 데이터의 집합
- 데이터 간의 관계를 기본 키와 이를 참조하는 외래 키로 표현함
- 관계 대수 : 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어
  - 일반 집합 연산자(→ 수학의 집합 개념을 릴레이션에 적용)
    |연산자|기호|표현|설명|
    |:--:|:--:|:--:|:--:|
    |합집합|∪|R∪S|합병 가능한 두 릴레이션 R과 S의 합집합|
    |교집합|∩|R∩S|릴레이션 R과 S에 속하는 모든 튜플로 결과 릴레이션 구성|
    |차집합|-|R-S|R에 존재하고 S에 미 존재하는 튜플로 결과 릴레이션 구성|
    |카디션 프로덕트|X|RXS|R과 S에 속한 모든 튜플을 연결해 만들어진 새로운 튜플로 릴레이션 구성|
  - 순수 관계 연산자(→ 특별히 개발한 관계 연산자)
    |연산자|기호|표현|설명|
    |:--:|:--:|:--:|:--:|
    |셀렉트|σ|σ조건(R)|릴레이션 R에서 조건을 만족하는 튜플 반환|
    |프로젝트|π|π속성리스트(R)|릴레이션 R에서 주어진 속성들의 값으로만 구성된 튜플 반환|
    |조인|▷◁|R▷◁S|공통 속성을 이용해 R과 S의 튜플들을 연결해 만들어진 튜플 반환|
    |디비전|÷|R÷S|릴레이션 S의 모든 튜플과 관련 있는 R의 튜플 반환|
- 관계 해석
  - 관계 해석이란 튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어이다.
  - Predicate Calculus(프레디킷 해석)에 기반, 비절차적 언어(원하는 정보가 무엇이라는 것만 선언)임


### 2-2. 논리 데이터 모델링 속성
- (1)개체(Entity)
  - 개체는 사물 또는 사건으로 정의되며 개체라고도 한다.
  - 사각형 표시 by Peter Chen Model
  - 표 형식 표시 by Crow's Foot Model
- (2)속성(Attribute)
  - 속성은 개체가 가지고 있는 요소 또는 성질이다.
  - 타원형 표시 by Peter Chen Model
  - 표 내부에 표시 by Crow's Foot Model
  - 속성명은 단수형으로 명명함
  - 개체명을 사용하지 않음
  - 속성이 필수 사항인지 아닌지(Not Null or Null) 고려하여 작성
- (3)관계(Relationship)
  - 두 개체 간의 관계를 정의한다.
  - 마름모 표시 by Peter Chen Model
  - 1:1 vs 1:m vs n:m by Crow's Foot Model


### 2-3. 개체-관계(E-R) 모델
- E-R 모델은 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델이다.
- 논리 데이터 모델링에서는 모든 이해당사자와 의사소통의 보조 자료로 E-R모델을 활용한다.
- 요구사항으로부터 얻어낸 정보들을 개체, 속성, 관계로 기술한 모델이다.
- E-R 다이어그램 기호
  |구성|기호|
  |:--:|:--:|
  |개체|사각형|
  |관계|마름모|
  |속성|타원|
  |다중 값 속성|이중타원|
  |관계-속성 연결|선|


### 3. 정규화(Normalization)
- 정규화는 관계형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정이다.
- 이상현상: 데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상(삽입, 삭제, 갱신 이상)
- 정규화의 단계
  |단계|조건|
  |:--:|:--:|
  |1정규형(1NF)|원자값으로 구성|
  |2정규형(2NF)|부분 함수 종속 제거(완전 함수적 종속 관계)|
  |3정규형(3NF)|이행함수 종속 제거|
  |보이스-코드 정규형(BCNF)|결정자 후보 키가 아닌 함수 종속 제거|
  |4정규형(4NF)|다치(다중 값) 종속 제거|
  |5정규형(5NF)|조인 종속 제거| 


### 3-1. 제1 정규화
- 원자값으로 구성, 반복 속성/중복 제거가 필요하다.
- 테이블 내의 속성값은 원자값을 가지고 있어야 한다.
- 이메일 주소가 속성에 2개 이상 가지고 있는 경우 원자값이 아니기 때문에 속성 1개만 가지도록 저장해야 한다.


### 3-2. 제2 정규화
- 부분함수 중속 제거(완전 함수적 종속 관계), 주식별자 아닌 속성을 분리한다.
- <고객명, 서비스 이름>이 <서비스 이용 기간>에 영향을 주고, <서비스 이름>이 <서비스 가격>에 영향을 주는 관계를 부분함수 종속 관계라고 한다.
- 이때 부분 관계인 <서비스 이름, 서비스 가격> 관계를 별도의 테이블로 두면 부분 함수 종속 관계가 제거된다.


### 3-3. 제3 정규화
- 이행함수 종속 제거, 속성에 종속적인 속성을 분리한다.
- <책번호>가 <출판사>에 영향을 주고, <출판사>가 <홈페이지>에 영향을 주는 관계인 A->B이고, B->C이면서 A->C 관계가 같이 있는 경우를 이행함수 종속 관계라고 한다.
- <책번호>는 <홈페이지>에 직접 영향을 주는 관계가 아니므로 <책번호, 출판사> 테이블, <출판사, 홈페이지> 테이블로 분리하여 이행 함수 관계를 제거한다.


### 3-4. 보이스-코드 정규화
- 결정자 함수 종속, 모든 결정자가 후보 키이다.
- <학번, 과목명>이 <교수명>에 영향을 주고, <교수명>이 <과목명>에 영향을 주는 관계로서, <교수명>은 <과목명>에 영향을 주지만 한 테이블에 같이 존재하고 <교수명>은 키가 아닌 상황이므로 결정자인 <교수명>이 후보 키가 아니다.
- <교수명>은 <과목명>에 직접 영향을 주기 때문에 <교수명, 과목명> 테이블로 분리하여 교수명이 후보 키 역할을 하도록 하여 보이스-코드 정규화를 만족한다.


### 3-5. 제4 정규화
- 다치(다중 값) 종속 제거, 특정 속성값에 따라 선택적인 속성을 분리한다.
- <개발자>마다 <자격증> 값들이 여러 개 존재하고, 특정 <개발자>마다 <언어>값들이 여러 개 존재하는 경우가 다치 종속 관계이다.
- <개발자, 자격증>, <개발자, 언어> 테이블로 분리하여 관리하면 다치 종속 관계를 제거한다.


### 3-6. 제5 정규화
- 조인 종속을 제거한다.
- 4차 정규화 테이블에 대헤 조인 연산을 수행하면 4차 정규화 수행 전 데이터와 다르게 되는 문제인 조인 종속이 발생한다.
- 이에 모든 속성 관계인 <개발자, 자격증>, <개발자 언어>, 그리고 <자격증, 언어> 관계에 대한 테이블을 만들어 조인했을 때 정확히 원래의 데이터로 복원할 수 있게 한다.


### 4. 반 정규화(De-Normalization)
- 반 정규화는 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법이다.
- 비정규화, 역정규화
- 특징
  - 장점) 데이터 구조 성능 향상, 관리의 효율성 증가
  - 단점) 데이터의 일관성 및 정합성 저하, 유지를 위한 비용 별도 발생


### 4-1. 반 정규화 기법
- 테이블 병합 : 1:1관계, 1:M관계를 통합하여 조인 횟수를 줄여 성능 향상
- 테이블 분할 : 테이블을 수직 또 는 수평으로 분할(파티셔닝)
- 중복 테이블 추가
- 컬럼 중복화
- 중복관계 추가


___



## (3-2) 물리 데이터 저장소 설계

### 1. 물리 데이터 모델링
- 논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정


### 2. 물리 데이터 모델링 변환 절차
- 1 개체를 테이블로 변환
- 2 속성을 컬럼으로 변환
- 3 UID(unique identifier, 고유 식별자)를 기본키로 변환
- 4 관계를 외래키로 변환
- 5 컬럼 유형과 길이 정의
- 6 반 정규화 실행


### 3. 물리 데이터 저장소 구성(1) 테이블 제약조건(Constraint) 설계
- 참조무결성 제약조건 
  - 릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조건
  - 두 개의 릴레이션이 기본키, 외래키를 통해 참조 관계를 형성할 경우, 참조하는 외래키의 값은 항상 참조되는 릴레이션에 기본키로 존재해야 한다.
- 제한(Restricted) : 참조무결성 원칙을 위배하는 연산 거절
- 연쇄(Cascade) : 참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제
- 널 값(Nullify) : 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 NULL 값을 넣는 옵션


### 3-1. 물리 데이터 저장소 구성(2) 인덱스(Index) 설계
- 인덱스
  - 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터 구조
  - 인덱스를 통해 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조회가 가능
- 인덱스 적용 기준(인덱스 분포도가 10~15% 이내인 경우)
  - 분포도 = (1/(컬럼 값의 종류)) X 100
  - 분포도 = (컬럼 값의 평균 Row 수) / (테이블의 총 Row 수) X 100
- 인덱스 컬럼 선정
  - 분포도가 좋은 컬럼은 단독적으로 생성
  - 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성
  - 결합 인덱스는 구성되는 컬럼 순서 선정(사용빈도, 유일성, 정렬 등)에 유의
  - 가능한 한 수정이 빈번하지 않은 컬럼을 선정
- 설계 시 고려사항
  - 지나치게 많은 인덱스는 오버헤드(Overhead)로 작용
  - 인덱스는 추가적인 저장 공간이 필요함 고려
  - 넓은 범위를 인덱스 처리 시 전체 처리보다 많은 오버헤드 발생 유의
  - 인덱스와 테이블의 저장 공간을 적절히 분리될 수 있도록 설계할 것


### 3-2. 물리 데이터 저장소 구성(3) 뷰(View) 설계
- 뷰 속성
  |속성|설명|
  |:--:|:--:|
  |Replace|뷰가 이미 존재하는 경우 재생성|
  |Force|본 테이블의 존재 여부와 관계없이 뷰 생성|
  |Noforce|기본 테이블이 존재할 때 뷰 생성|
  |With Check Option|서브 쿼리 내의 조건을 만족하는 행만 변경|
  |With Read Only|데이터 조작어 작업 불가|
- 설계 시 고려사항
  - 뷰 사용에 따라 수행속도에 문제 발생 유의
  - 뷰의 조건은 최적의 액세스 경로를 사용할 수 있도록 해야 함


### 3-3. 물리 데이터 저장소 구성(4) 클러스터(Cluster) 설계
- 클러스터
  - 대상이 되는 범위(모집단)의 요소를 몇 개 모은 단위체
- 적용 기준
  - 인덱스의 단점을 해결한 기법으로, 분포도가 넓을수록 유리함
  - 액세스 기법이 아니라 액세스 효율 향상을 위한 물리적 저장 방법
  - 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약 가능
  - 대량의 범위를 자주 액세스하는 경우 적용
  - 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용
  - 여러 개의 테이블이 빈번하게 조인을 일으킬 때 활용


### 3-4. 물리 데이터 저장소 구성(5) 파티션(Partition) 설계
- 레인지 파티셔닝(Range Partitioning)
  - 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법
  - 손쉬운 관리 기법을 제공하여 관리 시간의 단축 가능
  - ex. 우편번호, 일별, 월별, 분기별 등의 데이터
- 해시 파티셔닝(Hash Partitioning)
  - 파티션 키의 해시 함수 값에 의한 파티셔닝 기법
  - 균등한 데이터 분할이 가능하고 질의 성능 향상 가능
  - ex. 파티션을 위한 범위가 없는 데이터
- 리스트 파티셔닝(List Partitioning)
  - 특정 파티션에 저장될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법
  - 분포도가 비슷하고 데이터가 많은 SQL에서 컬럼의 조건이 많이 들어오는 경우 유용
  - ex. [ 한국, 일본, 중국 -> 아시아 ] [ 노르웨이, 스웨덴, 핀란드 -> 북유럽 ]
- 컴포지트 파티셔닝(Composite Partitioning)
  - 레인지 파티셔닝, 해시 파티셔닝, 리스트 파티셔닝 중 2개 이상의 파티셔닝을 결합하는 기법
  - 큰 파티션에 대한 I/O(Input/Output) 요청을 여러 파티션으로 분산 가능
- <파티션의 장점>
  - 성능 향상
  - 가용성 향상
  - 백업 가능
  - 경합 감소 : 디스크 스트라이핑으로 입출력 성능 향상, 디스크 컨트롤러에 대한 경합의 감소
 

### 3-5. 물리 데이터 저장소 구성(6) 디스크(Disk) 구성 설계
- 정확한 용량을 산정하여 디스크 사용의 효율 높이기
- 업무량이 집중되어 있는 디스크 분리 설계
- 입출력 경합을 최소화하여 데이터의 접근 성능 향상
- 파티션 수행 테이블은 별도 분류


